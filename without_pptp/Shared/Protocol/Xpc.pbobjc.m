// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: xpc.proto

// This CPP symbol can be defined to use imports that match up to the framework
// imports needed when using CocoaPods.
#if !defined(GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS)
 #define GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS 0
#endif

#if GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS
 #import <Protobuf/GPBProtocolBuffers_RuntimeSupport.h>
#else
 #import "GPBProtocolBuffers_RuntimeSupport.h"
#endif

 #import "Xpc.pbobjc.h"
// @@protoc_insertion_point(imports)

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#pragma clang diagnostic ignored "-Wdirect-ivar-access"

#pragma mark - XpcRoot

@implementation XpcRoot

@end

#pragma mark - XpcRoot_FileDescriptor

static GPBFileDescriptor *XpcRoot_FileDescriptor(void) {
  // This is called by +initialize so there is no need to worry
  // about thread safety of the singleton.
  static GPBFileDescriptor *descriptor = NULL;
  if (!descriptor) {
    GPBDebugCheckRuntimeVersion();
    descriptor = [[GPBFileDescriptor alloc] initWithPackage:@"onevpn"
                                                     syntax:GPBFileSyntaxProto2];
  }
  return descriptor;
}

#pragma mark - Enum Type

GPBEnumDescriptor *Type_EnumDescriptor(void) {
  static GPBEnumDescriptor *descriptor = NULL;
  if (!descriptor) {
    static const char *valueNames =
        "Version\000Pathes\000Status\000Connect\000Disconnect"
        "\000";
    static const int32_t values[] = {
        Type_Version,
        Type_Pathes,
        Type_Status,
        Type_Connect,
        Type_Disconnect,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(Type)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:Type_IsValidValue];
    if (!OSAtomicCompareAndSwapPtrBarrier(nil, worker, (void * volatile *)&descriptor)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL Type_IsValidValue(int32_t value__) {
  switch (value__) {
    case Type_Version:
    case Type_Pathes:
    case Type_Status:
    case Type_Connect:
    case Type_Disconnect:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum Protocol_Enum

GPBEnumDescriptor *Protocol_Enum_EnumDescriptor(void) {
  static GPBEnumDescriptor *descriptor = NULL;
  if (!descriptor) {
    static const char *valueNames =
        "Pptp\000L2Tp\000Tcp\000Udp\000";
    static const int32_t values[] = {
        Protocol_Enum_Pptp,
        Protocol_Enum_L2Tp,
        Protocol_Enum_Tcp,
        Protocol_Enum_Udp,
    };
    static const char *extraTextFormatInfo = "\001\001\003A\000";
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(Protocol_Enum)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:Protocol_Enum_IsValidValue
                              extraTextFormatInfo:extraTextFormatInfo];
    if (!OSAtomicCompareAndSwapPtrBarrier(nil, worker, (void * volatile *)&descriptor)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL Protocol_Enum_IsValidValue(int32_t value__) {
  switch (value__) {
    case Protocol_Enum_Pptp:
    case Protocol_Enum_L2Tp:
    case Protocol_Enum_Tcp:
    case Protocol_Enum_Udp:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum ExtStatus

GPBEnumDescriptor *ExtStatus_EnumDescriptor(void) {
  static GPBEnumDescriptor *descriptor = NULL;
  if (!descriptor) {
    static const char *valueNames =
        "Success\000AuthFailed\000OtherFailed\000";
    static const int32_t values[] = {
        ExtStatus_Success,
        ExtStatus_AuthFailed,
        ExtStatus_OtherFailed,
    };
    static const char *extraTextFormatInfo = "\003\000\007\000\001\n\000\002\013\000";
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(ExtStatus)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:ExtStatus_IsValidValue
                              extraTextFormatInfo:extraTextFormatInfo];
    if (!OSAtomicCompareAndSwapPtrBarrier(nil, worker, (void * volatile *)&descriptor)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL ExtStatus_IsValidValue(int32_t value__) {
  switch (value__) {
    case ExtStatus_Success:
    case ExtStatus_AuthFailed:
    case ExtStatus_OtherFailed:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum Status

GPBEnumDescriptor *Status_EnumDescriptor(void) {
  static GPBEnumDescriptor *descriptor = NULL;
  if (!descriptor) {
    static const char *valueNames =
        "Ok\000Fail\000";
    static const int32_t values[] = {
        Status_Ok,
        Status_Fail,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(Status)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:Status_IsValidValue];
    if (!OSAtomicCompareAndSwapPtrBarrier(nil, worker, (void * volatile *)&descriptor)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL Status_IsValidValue(int32_t value__) {
  switch (value__) {
    case Status_Ok:
    case Status_Fail:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum ServerStatus

GPBEnumDescriptor *ServerStatus_EnumDescriptor(void) {
  static GPBEnumDescriptor *descriptor = NULL;
  if (!descriptor) {
    static const char *valueNames =
        "Connected\000Disconnected\000";
    static const int32_t values[] = {
        ServerStatus_Connected,
        ServerStatus_Disconnected,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(ServerStatus)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:ServerStatus_IsValidValue];
    if (!OSAtomicCompareAndSwapPtrBarrier(nil, worker, (void * volatile *)&descriptor)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL ServerStatus_IsValidValue(int32_t value__) {
  switch (value__) {
    case ServerStatus_Connected:
    case ServerStatus_Disconnected:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - PathesRequest

@implementation PathesRequest

@dynamic hasOvpnPath, ovpnPath;
@dynamic hasPppdPath, pppdPath;

typedef struct PathesRequest__storage_ {
  uint32_t _has_storage_[1];
  NSString *ovpnPath;
  NSString *pppdPath;
} PathesRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "ovpnPath",
        .dataTypeSpecific.className = NULL,
        .number = PathesRequest_FieldNumber_OvpnPath,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PathesRequest__storage_, ovpnPath),
        .flags = GPBFieldRequired | GPBFieldTextFormatNameCustom,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "pppdPath",
        .dataTypeSpecific.className = NULL,
        .number = PathesRequest_FieldNumber_PppdPath,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PathesRequest__storage_, pppdPath),
        .flags = GPBFieldRequired | GPBFieldTextFormatNameCustom,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PathesRequest class]
                                     rootClass:[XpcRoot class]
                                          file:XpcRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PathesRequest__storage_)
                                         flags:0];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\002\001\010\000\002\010\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - VersionResponse

@implementation VersionResponse

@dynamic hasMajorVersion, majorVersion;
@dynamic hasMinorVersion, minorVersion;

typedef struct VersionResponse__storage_ {
  uint32_t _has_storage_[1];
  int32_t majorVersion;
  int32_t minorVersion;
} VersionResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "majorVersion",
        .dataTypeSpecific.className = NULL,
        .number = VersionResponse_FieldNumber_MajorVersion,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(VersionResponse__storage_, majorVersion),
        .flags = GPBFieldRequired | GPBFieldTextFormatNameCustom,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "minorVersion",
        .dataTypeSpecific.className = NULL,
        .number = VersionResponse_FieldNumber_MinorVersion,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(VersionResponse__storage_, minorVersion),
        .flags = GPBFieldRequired | GPBFieldTextFormatNameCustom,
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[VersionResponse class]
                                     rootClass:[XpcRoot class]
                                          file:XpcRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(VersionResponse__storage_)
                                         flags:0];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\002\001\014\000\002\014\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - Server

@implementation Server

@dynamic hasId_p, id_p;
@dynamic hasCountry, country;
@dynamic hasName, name;
@dynamic hasDns, dns;
@dynamic hasPort, port;
@dynamic hasProtocol, protocol;
@dynamic hasLogin, login;
@dynamic hasPassword, password;

typedef struct Server__storage_ {
  uint32_t _has_storage_[1];
  int32_t id_p;
  int32_t port;
  Protocol_Enum protocol;
  NSString *country;
  NSString *name;
  NSString *dns;
  NSString *login;
  NSString *password;
} Server__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "id_p",
        .dataTypeSpecific.className = NULL,
        .number = Server_FieldNumber_Id_p,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(Server__storage_, id_p),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "country",
        .dataTypeSpecific.className = NULL,
        .number = Server_FieldNumber_Country,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(Server__storage_, country),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "name",
        .dataTypeSpecific.className = NULL,
        .number = Server_FieldNumber_Name,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(Server__storage_, name),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "dns",
        .dataTypeSpecific.className = NULL,
        .number = Server_FieldNumber_Dns,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(Server__storage_, dns),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "port",
        .dataTypeSpecific.className = NULL,
        .number = Server_FieldNumber_Port,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(Server__storage_, port),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "protocol",
        .dataTypeSpecific.enumDescFunc = Protocol_Enum_EnumDescriptor,
        .number = Server_FieldNumber_Protocol,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(Server__storage_, protocol),
        .flags = GPBFieldRequired | GPBFieldHasEnumDescriptor,
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "login",
        .dataTypeSpecific.className = NULL,
        .number = Server_FieldNumber_Login,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(Server__storage_, login),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "password",
        .dataTypeSpecific.className = NULL,
        .number = Server_FieldNumber_Password,
        .hasIndex = 7,
        .offset = (uint32_t)offsetof(Server__storage_, password),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[Server class]
                                     rootClass:[XpcRoot class]
                                          file:XpcRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(Server__storage_)
                                         flags:0];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PathesResponse

@implementation PathesResponse

@dynamic hasStatus, status;

typedef struct PathesResponse__storage_ {
  uint32_t _has_storage_[1];
  Status status;
} PathesResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "status",
        .dataTypeSpecific.enumDescFunc = Status_EnumDescriptor,
        .number = PathesResponse_FieldNumber_Status,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PathesResponse__storage_, status),
        .flags = GPBFieldRequired | GPBFieldHasEnumDescriptor,
        .dataType = GPBDataTypeEnum,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PathesResponse class]
                                     rootClass:[XpcRoot class]
                                          file:XpcRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PathesResponse__storage_)
                                         flags:0];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ConnectResponse

@implementation ConnectResponse

@dynamic hasStatus, status;
@dynamic hasExtStatus, extStatus;

typedef struct ConnectResponse__storage_ {
  uint32_t _has_storage_[1];
  Status status;
  ExtStatus extStatus;
} ConnectResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "status",
        .dataTypeSpecific.enumDescFunc = Status_EnumDescriptor,
        .number = ConnectResponse_FieldNumber_Status,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ConnectResponse__storage_, status),
        .flags = GPBFieldRequired | GPBFieldHasEnumDescriptor,
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "extStatus",
        .dataTypeSpecific.enumDescFunc = ExtStatus_EnumDescriptor,
        .number = ConnectResponse_FieldNumber_ExtStatus,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(ConnectResponse__storage_, extStatus),
        .flags = GPBFieldRequired | GPBFieldTextFormatNameCustom | GPBFieldHasEnumDescriptor,
        .dataType = GPBDataTypeEnum,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ConnectResponse class]
                                     rootClass:[XpcRoot class]
                                          file:XpcRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ConnectResponse__storage_)
                                         flags:0];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\002\t\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - DisconnectResponse

@implementation DisconnectResponse

@dynamic hasStatus, status;

typedef struct DisconnectResponse__storage_ {
  uint32_t _has_storage_[1];
  Status status;
} DisconnectResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "status",
        .dataTypeSpecific.enumDescFunc = Status_EnumDescriptor,
        .number = DisconnectResponse_FieldNumber_Status,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(DisconnectResponse__storage_, status),
        .flags = GPBFieldRequired | GPBFieldHasEnumDescriptor,
        .dataType = GPBDataTypeEnum,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[DisconnectResponse class]
                                     rootClass:[XpcRoot class]
                                          file:XpcRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(DisconnectResponse__storage_)
                                         flags:0];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - StatusResponse

@implementation StatusResponse

@dynamic hasStatus, status;
@dynamic hasServer, server;

typedef struct StatusResponse__storage_ {
  uint32_t _has_storage_[1];
  ServerStatus status;
  Server *server;
} StatusResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "status",
        .dataTypeSpecific.enumDescFunc = ServerStatus_EnumDescriptor,
        .number = StatusResponse_FieldNumber_Status,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(StatusResponse__storage_, status),
        .flags = GPBFieldRequired | GPBFieldHasEnumDescriptor,
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "server",
        .dataTypeSpecific.className = GPBStringifySymbol(Server),
        .number = StatusResponse_FieldNumber_Server,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(StatusResponse__storage_, server),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[StatusResponse class]
                                     rootClass:[XpcRoot class]
                                          file:XpcRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(StatusResponse__storage_)
                                         flags:0];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - XPCRequest

@implementation XPCRequest

@dynamic msgOneOfCase;
@dynamic hasType, type;
@dynamic pathes;
@dynamic connect;

typedef struct XPCRequest__storage_ {
  uint32_t _has_storage_[2];
  Type type;
  PathesRequest *pathes;
  Server *connect;
} XPCRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "type",
        .dataTypeSpecific.enumDescFunc = Type_EnumDescriptor,
        .number = XPCRequest_FieldNumber_Type,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(XPCRequest__storage_, type),
        .flags = GPBFieldRequired | GPBFieldHasEnumDescriptor,
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "pathes",
        .dataTypeSpecific.className = GPBStringifySymbol(PathesRequest),
        .number = XPCRequest_FieldNumber_Pathes,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(XPCRequest__storage_, pathes),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "connect",
        .dataTypeSpecific.className = GPBStringifySymbol(Server),
        .number = XPCRequest_FieldNumber_Connect,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(XPCRequest__storage_, connect),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[XPCRequest class]
                                     rootClass:[XpcRoot class]
                                          file:XpcRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(XPCRequest__storage_)
                                         flags:0];
    static const char *oneofs[] = {
      "msg",
    };
    [localDescriptor setupOneofs:oneofs
                           count:(uint32_t)(sizeof(oneofs) / sizeof(char*))
                   firstHasIndex:-1];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

void XPCRequest_ClearMsgOneOfCase(XPCRequest *message) {
  GPBDescriptor *descriptor = [message descriptor];
  GPBOneofDescriptor *oneof = descriptor->oneofs_[0];
  GPBMaybeClearOneof(message, oneof, -1, 0);
}
#pragma mark - XPCResponse

@implementation XPCResponse

@dynamic msgOneOfCase;
@dynamic hasType, type;
@dynamic version;
@dynamic pathes;
@dynamic status;
@dynamic connect;
@dynamic disconnect;

typedef struct XPCResponse__storage_ {
  uint32_t _has_storage_[2];
  Type type;
  VersionResponse *version;
  PathesResponse *pathes;
  StatusResponse *status;
  ConnectResponse *connect;
  DisconnectResponse *disconnect;
} XPCResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "type",
        .dataTypeSpecific.enumDescFunc = Type_EnumDescriptor,
        .number = XPCResponse_FieldNumber_Type,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(XPCResponse__storage_, type),
        .flags = GPBFieldRequired | GPBFieldHasEnumDescriptor,
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "version",
        .dataTypeSpecific.className = GPBStringifySymbol(VersionResponse),
        .number = XPCResponse_FieldNumber_Version,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(XPCResponse__storage_, version),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "pathes",
        .dataTypeSpecific.className = GPBStringifySymbol(PathesResponse),
        .number = XPCResponse_FieldNumber_Pathes,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(XPCResponse__storage_, pathes),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "status",
        .dataTypeSpecific.className = GPBStringifySymbol(StatusResponse),
        .number = XPCResponse_FieldNumber_Status,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(XPCResponse__storage_, status),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "connect",
        .dataTypeSpecific.className = GPBStringifySymbol(ConnectResponse),
        .number = XPCResponse_FieldNumber_Connect,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(XPCResponse__storage_, connect),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "disconnect",
        .dataTypeSpecific.className = GPBStringifySymbol(DisconnectResponse),
        .number = XPCResponse_FieldNumber_Disconnect,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(XPCResponse__storage_, disconnect),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[XPCResponse class]
                                     rootClass:[XpcRoot class]
                                          file:XpcRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(XPCResponse__storage_)
                                         flags:0];
    static const char *oneofs[] = {
      "msg",
    };
    [localDescriptor setupOneofs:oneofs
                           count:(uint32_t)(sizeof(oneofs) / sizeof(char*))
                   firstHasIndex:-1];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

void XPCResponse_ClearMsgOneOfCase(XPCResponse *message) {
  GPBDescriptor *descriptor = [message descriptor];
  GPBOneofDescriptor *oneof = descriptor->oneofs_[0];
  GPBMaybeClearOneof(message, oneof, -1, 0);
}

#pragma clang diagnostic pop

// @@protoc_insertion_point(global_scope)
